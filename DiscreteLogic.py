import numpy as npimport cv2import mathfrom s4395897_ELEC4630_module.Math import line_length, line_gradient"""Credit to:https://stackoverflow.com/questions/32328179/opencv-3-0-python-lineiterator"""def createLineIterator(P1, P2, img):    """    Produces and array that consists of the coordinates and intensities of each pixel in a line between two points    Parameters:        -P1: a numpy array that consists of the coordinate of the first point (x,y)        -P2: a numpy array that consists of the coordinate of the second point (x,y)        -img: the image being processed    Returns:        -it: a numpy array that consists of the coordinates and intensities of each pixel in the radii (shape: [numPixels, 3], row = [x,y,intensity])    """    #define local variables for readability    imageH = img.shape[0]    imageW = img.shape[1]    P1X = P1[0]    P1Y = P1[1]    P2X = P2[0]    P2Y = P2[1]    #difference and absolute difference between points    #used to calculate slope and relative location between points    dX = P2X - P1X    dY = P2Y - P1Y    dXa = np.abs(dX)    dYa = np.abs(dY)    #predefine numpy array for output based on distance between points    itbuffer = np.empty(shape=(np.maximum(dYa,dXa),3),dtype=np.float32)    itbuffer.fill(np.nan)    #Obtain coordinates along the line using a form of Bresenham's algorithm    negY = P1Y > P2Y    negX = P1X > P2X    if P1X == P2X: #vertical line segment       itbuffer[:,0] = P1X       if negY:           itbuffer[:,1] = np.arange(P1Y - 1,P1Y - dYa - 1,-1)       else:           itbuffer[:,1] = np.arange(P1Y+1,P1Y+dYa+1)    elif P1Y == P2Y: #horizontal line segment       itbuffer[:,1] = P1Y       if negX:           itbuffer[:,0] = np.arange(P1X-1,P1X-dXa-1,-1)       else:           itbuffer[:,0] = np.arange(P1X+1,P1X+dXa+1)    else: #diagonal line segment       steepSlope = dYa > dXa       if steepSlope:           slope = dX.astype(np.float32)/dY.astype(np.float32)           if negY:               itbuffer[:,1] = np.arange(P1Y-1,P1Y-dYa-1,-1)           else:               itbuffer[:,1] = np.arange(P1Y+1,P1Y+dYa+1)           itbuffer[:,0] = (slope*(itbuffer[:,1]-P1Y)).astype(np.int) + P1X       else:           slope = dY.astype(np.float32)/dX.astype(np.float32)           if negX:               itbuffer[:,0] = np.arange(P1X-1,P1X-dXa-1,-1)           else:               itbuffer[:,0] = np.arange(P1X+1,P1X+dXa+1)           itbuffer[:,1] = (slope*(itbuffer[:,0]-P1X)).astype(np.int) + P1Y    #Remove points outside of image    colX = itbuffer[:,0]    colY = itbuffer[:,1]    itbuffer = itbuffer[(colX >= 0) & (colY >=0) & (colX<imageW) & (colY<imageH)]    #Get intensities from img ndarray    itbuffer[:,2] = img[itbuffer[:,1].astype(np.uint),itbuffer[:,0].astype(np.uint)]    return itbufferdef find_radius(center, point):    pass"""Finds the x, y point corresponding to the given center, radius and angle. Returns: x, y"""def find_point(center, radius, angle):    return (int(round(center[0] + radius * np.cos(angle))),     int(round(center[1] + radius * np.sin(angle))))def remove_close_lines(lines, threshold=100):    # Sort from shortest to longest lines to ensure the longest are retained    lengths = [line_length(line) for line in lines]    lineLengths = dict(zip(lengths, lines))    lines = [lineLengths[key] for key in sorted(lineLengths.keys())[::-1]]    # Eliminate close lines    for line in lines.__iter__():        for i, innerLine in enumerate(lines.__iter__()):            if np.array_equal(line, innerLine):                continue            if abs(line[0] - innerLine[0]) + abs(line[2] - innerLine[2]) < threshold:                lines.pop(i)                break    return linesdef compute_gradient(line):    x1, y1, x2, y2 = line    if x1 - x2 == 0:        x1 += 1    return math.atan((y2 - y1) / (x2 - x1))if __name__ == "__main__":    c = [300, 300]    print(find_point(c, 100, 0))